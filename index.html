<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D FPS Game with Guns, Enemies, Mods, and Tracers</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%; background: #222;
    font-family: Arial, sans-serif;
    color: white;
  }
  #modMenu {
    position: fixed;
    top: 10px; right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 8px;
    width: 200px;
    font-size: 14px;
    z-index: 10;
  }
  #modMenu label {
    display: block;
    margin: 6px 0;
    cursor: pointer;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #555;
    position: relative;
    z-index: 1;
  }
</style>
</head>
<body>

<div id="modMenu">
  <strong>Mods</strong><br/>
  <label><input type="checkbox" id="aimbotToggle" /> Aimbot</label>
  <label><input type="checkbox" id="noclipToggle" /> No Clip</label>
  <label><input type="checkbox" id="espToggle" /> ESP (Glow)</label>
  <label><input type="checkbox" id="tracerToggle" /> Tracers</label>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // Setup THREE.js
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x444444);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 10, 5);
  scene.add(light);

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  // Floor
  const floorGeometry = new THREE.PlaneGeometry(100, 100);
  const floorMaterial = new THREE.MeshStandardMaterial({color: 0x222222});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = - Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Obstacles (boxes)
  const obstacles = [];
  const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
  const boxMaterial = new THREE.MeshStandardMaterial({color: 0x6666ff});
  for(let i = 0; i < 10; i++){
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    box.position.set(
      (Math.random() - 0.5) * 40,
      1,
      (Math.random() - 0.5) * 40
    );
    scene.add(box);
    obstacles.push(box);
  }

  // Player
  const player = {
    velocity: new THREE.Vector3(0,0,0),
    direction: new THREE.Vector3(),
    speed: 10,
    canJump: false,
    height: 1.7,
    position: new THREE.Vector3(0, 1.7, 10),
  };

  camera.position.copy(player.position);

  // PointerLockControls
  const controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener('click', () => {
    controls.lock();
  });
  controls.getObject().position.copy(player.position);

  // Movement flags
  const move = { forward: false, backward: false, left: false, right: false };

  document.addEventListener('keydown', e => {
    switch(e.code){
      case 'KeyW': move.forward = true; break;
      case 'KeyS': move.backward = true; break;
      case 'KeyA': move.left = true; break;
      case 'KeyD': move.right = true; break;
      case 'Space':
        if(player.canJump){
          player.velocity.y = 8;
          player.canJump = false;
        }
        break;
    }
  });

  document.addEventListener('keyup', e => {
    switch(e.code){
      case 'KeyW': move.forward = false; break;
      case 'KeyS': move.backward = false; break;
      case 'KeyA': move.left = false; break;
      case 'KeyD': move.right = false; break;
    }
  });

  // Enemies
  const enemyGeometry = new THREE.BoxGeometry(1,2,1);
  const enemyMaterial = new THREE.MeshStandardMaterial({color: 0xff5555});
  const enemies = [];

  for(let i = 0; i < 5; i++){
    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial.clone());
    enemy.position.set(
      (Math.random() - 0.5) * 50,
      1,
      (Math.random() - 0.5) * 50
    );
    enemy.userData = { speed: 2, direction: new THREE.Vector3() };
    scene.add(enemy);
    enemies.push(enemy);
  }

  // Bullets
  const bullets = [];
  const bulletSpeed = 40;
  const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
  const bulletMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});

  // Mods state
  const mods = {
    aimbot: false,
    noclip: false,
    esp: false,
    tracers: false,
  };

  document.getElementById('aimbotToggle').addEventListener('change', (e) => {
    mods.aimbot = e.target.checked;
  });
  document.getElementById('noclipToggle').addEventListener('change', (e) => {
    mods.noclip = e.target.checked;
  });
  document.getElementById('espToggle').addEventListener('change', (e) => {
    mods.esp = e.target.checked;
  });
  document.getElementById('tracerToggle').addEventListener('change', (e) => {
    mods.tracers = e.target.checked;
    if(!mods.tracers){
      clearTracers();
    }
  });

  // Raycaster for collision & shooting
  const raycaster = new THREE.Raycaster();

  // Clock for delta
  const clock = new THREE.Clock();

  // Collision check player vs obstacles
  function checkCollision(newPos){
    const playerBox = new THREE.Box3().setFromCenterAndSize(
      newPos.clone().add(new THREE.Vector3(0, player.height/2, 0)),
      new THREE.Vector3(1, player.height, 1)
    );

    for(const obs of obstacles){
      const obsBox = new THREE.Box3().setFromObject(obs);
      if(playerBox.intersectsBox(obsBox)) return true;
    }
    return false;
  }

  // Enemy AI - move toward player
  function updateEnemies(delta){
    enemies.forEach(enemy => {
      const directionToPlayer = player.position.clone().sub(enemy.position);
      directionToPlayer.y = 0;
      const dist = directionToPlayer.length();
      if(dist > 0.5){
        directionToPlayer.normalize();
        enemy.userData.direction.copy(directionToPlayer);
        enemy.position.add(directionToPlayer.multiplyScalar(enemy.userData.speed * delta));
      }
    });
  }

  // Shoot function
  function shoot(){
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
    bullet.position.copy(camera.position);
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    bullet.userData = { velocity: dir.multiplyScalar(bulletSpeed) };
    scene.add(bullet);
    bullets.push(bullet);
  }

  let shootCooldown = 0;

  // Aimbot helper
  function aimbot(delta){
    if(!mods.aimbot) return;

    let closestEnemy = null;
    let closestDist = Infinity;
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);

    enemies.forEach(enemy => {
      const toEnemy = enemy.position.clone().sub(camera.position);
      const dist = toEnemy.length();
      toEnemy.normalize();
      const angle = camDir.angleTo(toEnemy);
      if(angle < Math.PI / 4 && dist < closestDist){
        closestDist = dist;
        closestEnemy = enemy;
      }
    });

    if(closestEnemy){
      const enemyPos = closestEnemy.position.clone();
      enemyPos.y = camera.position.y;
      const playerPos = camera.position.clone();
      playerPos.y = camera.position.y;

      const desiredDir = enemyPos.clone().sub(playerPos).normalize();
      const desiredAngle = Math.atan2(desiredDir.x, desiredDir.z);

      const euler = new THREE.Euler().setFromQuaternion(controls.getObject().quaternion);
      let currentYaw = euler.y;

      let angleDiff = desiredAngle - currentYaw;
      angleDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;

      const maxTurnSpeed = 5 * delta;
      angleDiff = THREE.MathUtils.clamp(angleDiff, -maxTurnSpeed, maxTurnSpeed);

      currentYaw += angleDiff;
      euler.y = currentYaw;
      controls.getObject().quaternion.setFromEuler(euler);

      if(Math.abs(angleDiff) < 0.1){
        if(shootCooldown <= 0){
          shoot();
          shootCooldown = 0.5;
        }
      }
    }
  }

  // Update bullets
  function updateBullets(delta){
    for(let i = bullets.length - 1; i >= 0; i--){
      const b = bullets[i];
      b.position.addScaledVector(b.userData.velocity, delta);

      if(b.position.distanceTo(camera.position) > 100){
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }

      for(let j = enemies.length - 1; j >= 0; j--){
        const enemy = enemies[j];
        const enemyBox = new THREE.Box3().setFromObject(enemy);
        if(enemyBox.containsPoint(b.position)){
          scene.remove(enemy);
          enemies.splice(j, 1);

          scene.remove(b);
          bullets.splice(i,1);
          break;
        }
      }
    }
  }

  // Player movement and collisions
  function playerMovement(delta){
    player.velocity.x -= player.velocity.x * 10.0 * delta;
    player.velocity.z -= player.velocity.z * 10.0 * delta;
    player.velocity.y -= 9.8 * 5 * delta;

    player.direction.z = Number(move.forward) - Number(move.backward);
    player.direction.x = Number(move.right) - Number(move.left);
    player.direction.normalize();

    if(move.forward || move.backward) player.velocity.z -= player.direction.z * player.speed * delta;
    if(move.left || move.right) player.velocity.x -= player.direction.x * player.speed * delta;

    const controlObject = controls.getObject();

    const velocity = new THREE.Vector3(player.velocity.x, player.velocity.y, player.velocity.z);
    const euler = new THREE.Euler(0, controlObject.rotation.y, 0, 'YXZ');
    velocity.applyEuler(euler);

    const newPos = controlObject.position.clone().add(velocity.clone().multiplyScalar(delta));

    if(!mods.noclip){
      if(newPos.y < player.height){
        player.velocity.y = 0;
        newPos.y = player.height;
        player.canJump = true;
      }
      if(!checkCollision(newPos)){
        controlObject.position.copy(newPos);
      }
    } else {
      controlObject.position.copy(newPos);
      if(newPos.y < 0) controlObject.position.y = 0;
      player.canJump = true;
    }

    player.position.copy(controlObject.position);
    camera.position.copy(controlObject.position);
  }

  // ESP glow
  function updateESP(){
    enemies.forEach(enemy => {
      if(mods.esp){
        enemy.material.emissive = new THREE.Color(0x00ff00);
        enemy.material.emissiveIntensity = 0.5;
      } else {
        enemy.material.emissiveIntensity = 0;
      }
    });
  }

  // --- Tracers ---

  // We'll draw tracers using THREE.Line objects

  const tracerMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  const tracers = [];

  function clearTracers(){
    tracers.forEach(line => scene.remove(line));
    tracers.length = 0;
  }

  function updateTracers(){
    clearTracers();
    if(!mods.tracers) return;

    enemies.forEach(enemy => {
      const points = [];
      // From player's camera position
      points.push(camera.position.clone());
      // To enemy's position, elevated to center of enemy box
      points.push(enemy.position.clone().add(new THREE.Vector3(0,1,0)));

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, tracerMaterial);
      scene.add(line);
      tracers.push(line);
    });
  }

  // Animation loop
  function animate(){
    const delta = clock.getDelta();
    shootCooldown -= delta;

    if(controls.isLocked === true){
      playerMovement(delta);
      updateEnemies(delta);
      aimbot(delta);
      updateBullets(delta);
      updateESP();
      updateTracers();
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  animate();

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

})();
</script>
</body>
</html>
