<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FPS Terrain Shooter with Collisions & Aimbot</title>
<style>
  body,html { margin:0; overflow:hidden; height:100%; background:#111; }
  canvas { display: block; }
  #startScreen {
    position: absolute;
    top:0; left:0; width:100%; height:100%;
    background: rgba(0,0,0,0.85);
    color: white;
    font-family: monospace;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    user-select:none;
    pointer-events:auto;
    z-index: 10;
  }
  #startButton {
    padding: 15px 30px;
    background: #0077ff;
    border: none;
    font-size: 20px;
    color: white;
    cursor: pointer;
    border-radius: 5px;
    user-select:none;
  }
  #fovCircle {
    position: absolute;
    border: 2px solid rgba(0,255,0,0.6);
    border-radius: 50%;
    pointer-events:none;
    display:none;
    z-index: 5;
  }
  #modMenu {
    position: absolute;
    top: 10px; right: 10px;
    background: rgba(20,20,20,0.8);
    color: #ddd;
    padding: 10px;
    font-family: monospace;
    font-size: 14px;
    display:none;
    user-select:none;
    z-index: 5;
  }
  #modMenu label {
    display: block;
    margin-bottom: 6px;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="startScreen">
  <div>Click the button below to start</div>
  <button id="startButton">Start Game</button>
</div>

<div id="overlay"></div>
<div id="fovCircle"></div>
<div id="modMenu">
  <label><input type="checkbox" id="toggleAimbot" checked> Aimbot</label>
  <label><input type="checkbox" id="toggleESP" checked> ESP</label>
  <label><input type="checkbox" id="toggleTracers" checked> Tracers</label>
  <div style="margin-top:10px; font-size:12px; color:#777;">Press 'P' to toggle this menu</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  const startScreen = document.getElementById('startScreen');
  const startButton = document.getElementById('startButton');

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.PointerLockControls(camera, document.body);

  // Start game when start button clicked
  startButton.addEventListener('click', () => {
    controls.lock();
  });

  controls.addEventListener('lock', () => {
    startScreen.style.display = 'none';
  });
  controls.addEventListener('unlock', () => {
    startScreen.style.display = 'flex';
  });

  // Lights
  const ambientLight = new THREE.AmbientLight(0x888888);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(20, 100, 20);
  scene.add(dirLight);

  // Floor (terrain) with a subtle green color
  const floorGeometry = new THREE.PlaneGeometry(100, 100, 32, 32);
  const floorMaterial = new THREE.MeshPhongMaterial({color:0x228833});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Walls/boxes obstacles with collision
  const obstacles = [];
  const obstacleGeom = new THREE.BoxGeometry(4, 4, 4);
  const obstacleMat = new THREE.MeshPhongMaterial({color: 0x555555});
  for(let i=0; i<15; i++) {
    const obs = new THREE.Mesh(obstacleGeom, obstacleMat);
    obs.position.set(
      (Math.random()-0.5)*80,
      2,
      (Math.random()-0.5)*80
    );
    scene.add(obs);
    obstacles.push(obs);
  }

  // Player physics variables
  let velocity = new THREE.Vector3();
  let direction = new THREE.Vector3();
  let canJump = false;
  let onObject = false;
  const gravity = 30;
  const moveSpeed = 15;

  // Starting position
  controls.getObject().position.set(0, 2, 0);
  scene.add(controls.getObject());

  // Enemies
  class Enemy {
    constructor() {
      this.group = new THREE.Group();
      const headGeom = new THREE.SphereGeometry(1, 12, 12);
      const headMat = new THREE.MeshBasicMaterial({color:0xff4444});
      this.head = new THREE.Mesh(headGeom, headMat);
      this.group.add(this.head);

      const bodyGeom = new THREE.BoxGeometry(1.5, 2, 1);
      const bodyMat = new THREE.MeshBasicMaterial({color:0xaa2222});
      this.body = new THREE.Mesh(bodyGeom, bodyMat);
      this.body.position.y = -1.5;
      this.group.add(this.body);

      this.group.position.set(
        (Math.random()-0.5)*70,
        1,
        (Math.random()-0.5)*70
      );
      this.speed = 1 + Math.random();
      this.direction = new THREE.Vector3(
        (Math.random()-0.5),
        0,
        (Math.random()-0.5)
      ).normalize();
      scene.add(this.group);
    }
    update(delta) {
      this.group.position.add(this.direction.clone().multiplyScalar(this.speed * delta));

      if(this.group.position.x > 48 || this.group.position.x < -48) this.direction.x *= -1;
      if(this.group.position.z > 48 || this.group.position.z < -48) this.direction.z *= -1;

      for(let obs of obstacles) {
        if (this.checkCollision(obs)) {
          this.direction.multiplyScalar(-1);
          break;
        }
      }
    }
    checkCollision(mesh) {
      const box1 = new THREE.Box3().setFromObject(this.group);
      const box2 = new THREE.Box3().setFromObject(mesh);
      return box1.intersectsBox(box2);
    }
  }

  const enemies = [];
  for(let i=0; i<12; i++) enemies.push(new Enemy());

  // Gun model
  const gun = new THREE.Group();
  const gunBodyGeom = new THREE.BoxGeometry(0.2, 0.2, 1);
  const gunBodyMat = new THREE.MeshPhongMaterial({color:0x3333ff});
  const gunBody = new THREE.Mesh(gunBodyGeom, gunBodyMat);
  gunBody.position.z = -0.5;
  gun.add(gunBody);
  scene.add(gun);

  function updateGunPosition() {
    const camPos = camera.position.clone();
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    const right = new THREE.Vector3();
    right.crossVectors(camera.up, camDir).normalize();
    gun.position.copy(camPos).add(right.multiplyScalar(-0.5)).add(new THREE.Vector3(0,-0.3,0));
    gun.lookAt(camPos.clone().add(camDir.multiplyScalar(10)));
  }

  const keys = {};
  window.addEventListener('keydown', (e) => keys[e.code] = true);
  window.addEventListener('keyup', (e) => keys[e.code] = false);

  let isAiming = false;
  window.addEventListener('mousedown', e => { if(e.button === 2) isAiming = true; });
  window.addEventListener('mouseup', e => { if(e.button === 2) isAiming = false; });
  window.addEventListener('contextmenu', e => e.preventDefault());

  // Overlay for ESP and tracers
  const overlay = document.getElementById('overlay');
  const overlayCanvas = document.createElement('canvas');
  overlayCanvas.width = window.innerWidth;
  overlayCanvas.height = window.innerHeight;
  overlay.appendChild(overlayCanvas);
  const overlayCtx = overlayCanvas.getContext('2d');

  // FOV Circle for aimbot
  const fovCircle = document.getElementById('fovCircle');
  const fovRadius = 150;

  // Mod menu controls
  const modMenu = document.getElementById('modMenu');
  const toggleAimbot = document.getElementById('toggleAimbot');
  const toggleESP = document.getElementById('toggleESP');
  const toggleTracers = document.getElementById('toggleTracers');
  let modMenuVisible = false;

  window.addEventListener('keydown', e => {
    if(e.code === 'KeyP') {
      modMenuVisible = !modMenuVisible;
      modMenu.style.display = modMenuVisible ? 'block' : 'none';
    }
  });

  const clock = new THREE.Clock();

  function playerCollides(pos) {
    // Check collision with obstacles
    const playerBox = new THREE.Box3(
      new THREE.Vector3(pos.x - 0.5, pos.y - 1, pos.z - 0.5),
      new THREE.Vector3(pos.x + 0.5, pos.y + 1, pos.z + 0.5)
    );
    for(let obs of obstacles) {
      const obsBox = new THREE.Box3().setFromObject(obs);
      if(playerBox.intersectsBox(obsBox)) return true;
    }
    // Boundaries of the map
    if(pos.x < -50 || pos.x > 50 || pos.z < -50 || pos.z > 50) return true;
    return false;
  }

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if (controls.isLocked) {
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      velocity.y -= gravity * delta;

      direction.z = Number(keys['KeyW']) - Number(keys['KeyS']);
      direction.x = Number(keys['KeyD']) - Number(keys['KeyA']);
      direction.normalize();

      if (direction.length() > 0) {
        // Move on the XZ plane
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        camDir.y = 0;
        camDir.normalize();

        const camRight = new THREE.Vector3();
        camRight.crossVectors(camera.up, camDir).normalize();

        velocity.x -= camRight.x * direction.x * moveSpeed * delta;
        velocity.z -= camRight.z * direction.x * moveSpeed * delta;
        velocity.x -= camDir.x * direction.z * moveSpeed * delta;
        velocity.z -= camDir.z * direction.z * moveSpeed * delta;
      }

      // Calculate tentative new position
      const pos = controls.getObject().position.clone();
      pos.x += velocity.x * delta;
      pos.y += velocity.y * delta;
      pos.z += velocity.z * delta;

      // Floor collision
      if (pos.y < 2) {
        velocity.y = 0;
        pos.y = 2;
        canJump = true;
      }

      // Player collision with obstacles
      if (!playerCollides(pos)) {
        controls.getObject().position.copy(pos);
      } else {
        // Cancel velocity movement if collision
        velocity.x = 0;
        velocity.z = 0;
      }
    }

    enemies.forEach(enemy => enemy.update(delta));

    updateGunPosition();

    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    if (toggleESP.checked || toggleTracers.checked) {
      enemies.forEach(enemy => {
        const enemyPos = enemy.group.position.clone();
        enemyPos.y += 1.5;
        const vector = enemyPos.project(camera);
        const x = (vector.x * 0.5 + 0.5) * overlayCanvas.width;
        const y = (-vector.y * 0.5 + 0.5) * overlayCanvas.height;

        if (vector.z > 1 || vector.z < 0) return;

        if (toggleESP.checked) {
          overlayCtx.strokeStyle = 'red';
          overlayCtx.lineWidth = 2;
          overlayCtx.strokeRect(x - 20, y - 40, 40, 60);
        }
        if (toggleTracers.checked) {
          overlayCtx.strokeStyle = 'lime';
          overlayCtx.lineWidth = 1;
          overlayCtx.beginPath();
          overlayCtx.moveTo(overlayCanvas.width/2, overlayCanvas.height);
          overlayCtx.lineTo(x, y);
          overlayCtx.stroke();
        }
      });
    }

    if (isAiming && toggleAimbot.checked) {
      fovCircle.style.display = 'block';
      fovCircle.style.width = fovRadius * 2 + 'px';
      fovCircle.style.height = fovRadius * 2 + 'px';
      fovCircle.style.left = (window.innerWidth/2 - fovRadius) + 'px';
      fovCircle.style.top = (window.innerHeight/2 - fovRadius) + 'px';
    } else {
      fovCircle.style.display = 'none';
    }

    if (isAiming && toggleAimbot.checked) {
      let bestEnemy = null;
      let bestDist = fovRadius;

      enemies.forEach(enemy => {
        const enemyPos = enemy.group.position.clone();
        enemyPos.y += 1.5;
        const vector = enemyPos.project(camera);
        const x = (vector.x * 0.5 + 0.5) * overlayCanvas.width;
        const y = (-vector.y * 0.5 + 0.5) * overlayCanvas.height;

        if (vector.z > 1 || vector.z < 0) return;

        const dist = Math.hypot(x - overlayCanvas.width/2, y - overlayCanvas.height/2);
        if(dist < bestDist) {
          bestDist = dist;
          bestEnemy = enemy;
        }
      });

      if(bestEnemy) {
        const enemyPos = bestEnemy.group.position.clone();
        enemyPos.y += 1.5;

        const playerPos = controls.getObject().position.clone().add(new THREE.Vector3(0,1.6,0));
        const targetDir = enemyPos.clone().sub(playerPos).normalize();

        const targetYaw = Math.atan2(targetDir.x, targetDir.z);
        const targetPitch = Math.asin(targetDir.y);

        const camEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');

        const lerpFactor = 0.15;
        let newYaw = THREE.MathUtils.lerpAngle(camEuler.y, targetYaw, lerpFactor);
        let newPitch = THREE.MathUtils.lerp(camEuler.x, targetPitch, lerpFactor);

        newPitch = THREE.MathUtils.clamp(newPitch, -Math.PI/2, Math.PI/2);

        camEuler.y = newYaw;
        camEuler.x = newPitch;

        camera.quaternion.setFromEuler(camEuler);
        controls.getObject().rotation.y = newYaw;
      }
    }

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

    overlayCanvas.width = window.innerWidth;
    overlayCanvas.height = window.innerHeight;
  });

})();
</script>

</body>
</html>
