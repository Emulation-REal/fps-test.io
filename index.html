<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FPS Target Practice with Aimbot</title>
<style>
  body,html { margin:0; overflow:hidden; height:100%; background:#111;}
  canvas { display: block; }
  #overlay {
    position: absolute;
    top:0; left:0; pointer-events:none;
    width: 100%; height: 100%;
  }
  #fovCircle {
    position: absolute;
    border: 2px solid rgba(0,255,0,0.6);
    border-radius: 50%;
    pointer-events:none;
    display:none;
  }
  #modMenu {
    position: absolute;
    top: 10px; right: 10px;
    background: rgba(20,20,20,0.8);
    color: #ddd;
    padding: 10px;
    font-family: monospace;
    font-size: 14px;
    display:none;
    user-select:none;
  }
  #modMenu label {
    display: block;
    margin-bottom: 6px;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="overlay"></div>
<div id="fovCircle"></div>
<div id="modMenu">
  <label><input type="checkbox" id="toggleAimbot" checked> Aimbot</label>
  <label><input type="checkbox" id="toggleESP" checked> ESP</label>
  <label><input type="checkbox" id="toggleTracers" checked> Tracers</label>
  <div style="margin-top:10px; font-size:12px; color:#777;">Press 'P' to toggle this menu</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Controls setup (PointerLockControls)
  const controls = new THREE.PointerLockControls(camera, document.body);

  // Click to lock pointer for FPS controls
  document.body.addEventListener('click', () => {
    if (!controls.isLocked) controls.lock();
  });

  // Simple floor
  const floorGeometry = new THREE.PlaneGeometry(100, 100);
  const floorMaterial = new THREE.MeshPhongMaterial({color:0x222222});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Obstacles (boxes)
  const obstacles = [];
  const obstacleGeom = new THREE.BoxGeometry(4, 4, 4);
  const obstacleMat = new THREE.MeshPhongMaterial({color: 0x555555});
  for(let i=0; i<15; i++) {
    const obs = new THREE.Mesh(obstacleGeom, obstacleMat);
    obs.position.set(
      (Math.random()-0.5)*80,
      2,
      (Math.random()-0.5)*80
    );
    scene.add(obs);
    obstacles.push(obs);
  }

  // Light
  const ambientLight = new THREE.AmbientLight(0x666666);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(20, 50, 10);
  scene.add(dirLight);

  // Enemies
  class Enemy {
    constructor() {
      this.group = new THREE.Group();
      // simple sphere for enemy head
      const headGeom = new THREE.SphereGeometry(1, 12, 12);
      const headMat = new THREE.MeshBasicMaterial({color:0xff4444});
      this.head = new THREE.Mesh(headGeom, headMat);
      this.group.add(this.head);

      // simple box for body
      const bodyGeom = new THREE.BoxGeometry(1.5, 2, 1);
      const bodyMat = new THREE.MeshBasicMaterial({color:0xaa2222});
      this.body = new THREE.Mesh(bodyGeom, bodyMat);
      this.body.position.y = -1.5;
      this.group.add(this.body);

      // start position
      this.group.position.set(
        (Math.random()-0.5)*70,
        1,
        (Math.random()-0.5)*70
      );
      this.speed = 1 + Math.random(); // movement speed
      this.direction = new THREE.Vector3(
        (Math.random()-0.5),
        0,
        (Math.random()-0.5)
      ).normalize();
      scene.add(this.group);
    }
    update(delta) {
      // Move enemy in direction
      this.group.position.add(this.direction.clone().multiplyScalar(this.speed * delta));

      // Bounce from map edges (-50 to 50)
      if(this.group.position.x > 50 || this.group.position.x < -50) this.direction.x *= -1;
      if(this.group.position.z > 50 || this.group.position.z < -50) this.direction.z *= -1;

      // Simple obstacle avoidance - reverse direction if close
      for(let obs of obstacles) {
        const dist = obs.position.distanceTo(this.group.position);
        if(dist < 4) {
          this.direction.multiplyScalar(-1);
          break;
        }
      }
    }
  }

  const enemies = [];
  for(let i=0; i<12; i++) enemies.push(new Enemy());

  // Gun model
  const gun = new THREE.Group();
  const gunBodyGeom = new THREE.BoxGeometry(0.2, 0.2, 1);
  const gunBodyMat = new THREE.MeshPhongMaterial({color:0x3333ff});
  const gunBody = new THREE.Mesh(gunBodyGeom, gunBodyMat);
  gunBody.position.z = -0.5;
  gun.add(gunBody);
  scene.add(gun);

  // Position gun relative to camera
  function updateGunPosition() {
    const camPos = camera.position.clone();
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    // Offset to right + down
    const right = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    right.crossVectors(camera.up, camDir).normalize();
    gun.position.copy(camPos).add(right.multiplyScalar(-0.5)).add(new THREE.Vector3(0,-0.3,0));
    // Point forward same as camera
    gun.lookAt(camPos.clone().add(camDir.multiplyScalar(10)));
  }

  // Controls state
  const keys = {};
  window.addEventListener('keydown', (e) => keys[e.code] = true);
  window.addEventListener('keyup', (e) => keys[e.code] = false);

  // Aiming state (right mouse button)
  let isAiming = false;
  window.addEventListener('mousedown', e => {
    if(e.button === 2) isAiming = true;
  });
  window.addEventListener('mouseup', e => {
    if(e.button === 2) isAiming = false;
  });

  // Prevent context menu on right-click
  window.addEventListener('contextmenu', e => e.preventDefault());

  // Player movement speed
  const speed = 15;

  // Raycaster for aiming and aimbot
  const raycaster = new THREE.Raycaster();

  // Overlay canvas for ESP and tracers
  const overlay = document.getElementById('overlay');
  const overlayCanvas = document.createElement('canvas');
  overlayCanvas.width = window.innerWidth;
  overlayCanvas.height = window.innerHeight;
  overlay.appendChild(overlayCanvas);
  const overlayCtx = overlayCanvas.getContext('2d');

  // FOV circle for visual aimbot
  const fovCircle = document.getElementById('fovCircle');
  const fovRadius = 150; // pixels radius for aimbot FOV circle

  // Mod menu and toggles
  const modMenu = document.getElementById('modMenu');
  const toggleAimbot = document.getElementById('toggleAimbot');
  const toggleESP = document.getElementById('toggleESP');
  const toggleTracers = document.getElementById('toggleTracers');
  let modMenuVisible = false;

  window.addEventListener('keydown', e => {
    if(e.code === 'KeyP') {
      modMenuVisible = !modMenuVisible;
      modMenu.style.display = modMenuVisible ? 'block' : 'none';
    }
  });

  // Main update loop
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    if (controls.isLocked) {
      // Movement
      let dir = new THREE.Vector3();
      if(keys['KeyW']) dir.z -= 1;
      if(keys['KeyS']) dir.z += 1;
      if(keys['KeyA']) dir.x -= 1;
      if(keys['KeyD']) dir.x += 1;
      dir.normalize();
      if(dir.length() > 0) {
        const moveVector = dir.clone().applyQuaternion(camera.quaternion).multiplyScalar(speed * delta);
        controls.getObject().position.add(moveVector);
        // Clamp player inside map boundaries (-48 to 48)
        controls.getObject().position.x = THREE.MathUtils.clamp(controls.getObject().position.x, -48, 48);
        controls.getObject().position.z = THREE.MathUtils.clamp(controls.getObject().position.z, -48, 48);
      }
    }

    // Update enemies
    enemies.forEach(enemy => enemy.update(delta));

    // Update gun position/rotation
    updateGunPosition();

    // Draw overlay ESP/tracers/fov circle
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    if (toggleESP.checked || toggleTracers.checked) {
      enemies.forEach(enemy => {
        // Project enemy position to 2D screen
        const enemyPos = enemy.group.position.clone();
        enemyPos.y += 1.5; // target approx head height
        const vector = enemyPos.project(camera);
        const x = (vector.x * 0.5 + 0.5) * overlayCanvas.width;
        const y = (-vector.y * 0.5 + 0.5) * overlayCanvas.height;

        if (vector.z > 1 || vector.z < 0) return; // behind camera or too far

        if (toggleESP.checked) {
          // Draw box around enemy (simple fixed size)
          overlayCtx.strokeStyle = 'red';
          overlayCtx.lineWidth = 2;
          overlayCtx.strokeRect(x - 20, y - 40, 40, 60);
        }
        if (toggleTracers.checked) {
          // Draw line from bottom center to enemy
          overlayCtx.strokeStyle = 'lime';
          overlayCtx.lineWidth = 1;
          overlayCtx.beginPath();
          overlayCtx.moveTo(overlayCanvas.width/2, overlayCanvas.height);
          overlayCtx.lineTo(x, y);
          overlayCtx.stroke();
        }
      });
    }

    // Visual aimbot FOV circle
    if (isAiming && toggleAimbot.checked) {
      fovCircle.style.display = 'block';
      fovCircle.style.width = fovRadius * 2 + 'px';
      fovCircle.style.height = fovRadius * 2 + 'px';
      fovCircle.style.left = (window.innerWidth/2 - fovRadius) + 'px';
      fovCircle.style.top = (window.innerHeight/2 - fovRadius) + 'px';
    } else {
      fovCircle.style.display = 'none';
    }

    // Aimbot targeting
    if (isAiming && toggleAimbot.checked) {
      // Find closest enemy inside FOV circle
      let bestEnemy = null;
      let bestDist = fovRadius;

      enemies.forEach(enemy => {
        const enemyPos = enemy.group.position.clone();
        enemyPos.y += 1.5;
        const vector = enemyPos.project(camera);
        const x = (vector.x * 0.5 + 0.5) * overlayCanvas.width;
        const y = (-vector.y * 0.5 + 0.5) * overlayCanvas.height;

        if (vector.z > 1 || vector.z < 0) return;

        // Distance from screen center
        const dist = Math.hypot(x - overlayCanvas.width/2, y - overlayCanvas.height/2);
        if(dist < bestDist) {
          bestDist = dist;
          bestEnemy = enemy;
        }
      });

      if(bestEnemy) {
        // Aim camera smoothly at enemy
        const enemyPos = bestEnemy.group.position.clone();
        enemyPos.y += 1.5;

        const playerPos = controls.getObject().position.clone().add(new THREE.Vector3(0,1.6,0));
        const targetDir = enemyPos.clone().sub(playerPos).normalize();

        // Calculate target yaw and pitch
        const targetYaw = Math.atan2(targetDir.x, targetDir.z);
        const targetPitch = Math.asin(targetDir.y);

        // Current camera rotation (Euler)
        const camEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');

        // Smoothly interpolate yaw and pitch
        const lerpFactor = 0.15;
        let newYaw = THREE.MathUtils.lerpAngle(camEuler.y, targetYaw, lerpFactor);
        let newPitch = THREE.MathUtils.lerp(camEuler.x, targetPitch, lerpFactor);

        // Clamp pitch so you don't flip over (look up/down)
        newPitch = THREE.MathUtils.clamp(newPitch, -Math.PI/2, Math.PI/2);

        camEuler.y = newYaw;
        camEuler.x = newPitch;

        camera.quaternion.setFromEuler(camEuler);

        // Also update controls target so the pointer lock yaw/pitch is synced
        controls.getObject().rotation.y = newYaw;
      }
    }

    renderer.render(scene, camera);
  }

  animate();

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

    overlayCanvas.width = window.innerWidth;
    overlayCanvas.height = window.innerHeight;
  });

})();
</script>

</body>
</html>
