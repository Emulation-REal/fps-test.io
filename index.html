<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D FPS Game with Mod Menu</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: #111;
  }
  #startScreen {
    position: absolute;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.85);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 9999;
  }
  #startBtn {
    padding: 15px 30px;
    font-size: 20px;
    cursor: pointer;
    border: none;
    border-radius: 6px;
    background: #28a745;
    color: white;
    transition: background 0.3s;
  }
  #startBtn:hover {
    background: #218838;
  }
  #modMenu {
    position: fixed;
    top: 50px;
    right: 20px;
    background: rgba(20, 20, 20, 0.9);
    border: 2px solid #44f;
    padding: 15px;
    color: white;
    font-family: monospace;
    display: none;
    width: 220px;
    z-index: 9998;
    border-radius: 8px;
  }
  #modMenu label {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    cursor: pointer;
  }
  #modMenu label input {
    margin-right: 8px;
    cursor: pointer;
  }
  #modMenu h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-weight: bold;
    font-size: 18px;
    border-bottom: 1px solid #44f;
    padding-bottom: 5px;
  }
  #fovSlider {
    width: 100%;
  }
</style>
</head>
<body>

<div id="startScreen">
  <h1>3D FPS Game</h1>
  <button id="startBtn">Start</button>
  <p>Click Start to lock pointer and play</p>
</div>

<div id="modMenu">
  <h3>Mod Menu (Toggle with ;)</h3>
  <label><input type="checkbox" id="espToggle" /> ESP (Show players)</label>
  <label><input type="checkbox" id="tracersToggle" /> Tracers</label>
  <label><input type="checkbox" id="aimbotToggle" /> Aimbot (Aim only)</label>
  <label>FOV: <input type="range" id="fovSlider" min="30" max="120" value="75" /></label>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
  // Basic setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x888888);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 5);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Floor
  const floorGeo = new THREE.PlaneGeometry(50, 50);
  const floorMat = new THREE.MeshStandardMaterial({color: 0x444444});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Walls (box colliders)
  const walls = [];
  const wallGeo = new THREE.BoxGeometry(10, 3, 0.5);
  const wallMat = new THREE.MeshStandardMaterial({color: 0x555555});

  // Back wall
  const backWall = new THREE.Mesh(wallGeo, wallMat);
  backWall.position.set(0, 1.5, -5);
  scene.add(backWall);
  walls.push(backWall);

  // Front wall
  const frontWall = new THREE.Mesh(wallGeo, wallMat);
  frontWall.position.set(0, 1.5, 5);
  scene.add(frontWall);
  walls.push(frontWall);

  // Left wall
  const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 10), wallMat);
  leftWall.position.set(-5, 1.5, 0);
  scene.add(leftWall);
  walls.push(leftWall);

  // Right wall
  const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 10), wallMat);
  rightWall.position.set(5, 1.5, 0);
  scene.add(rightWall);
  walls.push(rightWall);

  // Some inner boxes for hiding
  function createBox(x, z) {
    const geo = new THREE.BoxGeometry(2, 3, 2);
    const mat = new THREE.MeshStandardMaterial({color: 0x666666});
    const box = new THREE.Mesh(geo, mat);
    box.position.set(x, 1.5, z);
    scene.add(box);
    walls.push(box);
  }
  createBox(-2, 0);
  createBox(2, 2);

  // Player setup
  const player = {
    velocity: new THREE.Vector3(),
    direction: new THREE.Vector3(),
    speed: 5,
    canJump: false,
    height: 1.6
  };

  // Pointer lock controls
  const controls = new THREE.PointerLockControls(camera, document.body);

  // Movement keys
  const keys = {};
  document.addEventListener('keydown', e => { keys[e.code] = true; });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  // Start screen and button
  const startScreen = document.getElementById('startScreen');
  const startBtn = document.getElementById('startBtn');

  startBtn.addEventListener('click', () => {
    controls.lock();

    // Error catch for pointer lock
    document.addEventListener('pointerlockerror', () => {
      alert('Pointer Lock failed. Please click the Start button again.');
    }, {once: true});
  });

  controls.addEventListener('lock', () => {
    startScreen.style.display = 'none';
    // Reset player position
    player.position = new THREE.Vector3(0, player.height, 0);
    controls.getObject().position.copy(player.position);
    velocityY = 0;
    animate();
  });

  controls.addEventListener('unlock', () => {
    startScreen.style.display = 'flex';
  });

  // Physics for player movement and collision
  let velocityY = 0;
  const gravity = -9.8;
  const deltaTime = 1/60;

  function checkCollision(pos) {
    // Simple AABB collision detection
    for (const wall of walls) {
      const box = new THREE.Box3().setFromObject(wall);
      // Create player box (approximate)
      const playerBox = new THREE.Box3(
        new THREE.Vector3(pos.x - 0.3, pos.y - player.height, pos.z - 0.3),
        new THREE.Vector3(pos.x + 0.3, pos.y, pos.z + 0.3)
      );
      if (box.intersectsBox(playerBox)) {
        return true;
      }
    }
    return false;
  }

  // Mods state
  let mods = {
    esp: false,
    tracers: false,
    aimbot: false,
    fov: 75
  };

  // Mod Menu elements
  const modMenu = document.getElementById('modMenu');
  const espToggle = document.getElementById('espToggle');
  const tracersToggle = document.getElementById('tracersToggle');
  const aimbotToggle = document.getElementById('aimbotToggle');
  const fovSlider = document.getElementById('fovSlider');

  espToggle.addEventListener('change', e => mods.esp = e.target.checked);
  tracersToggle.addEventListener('change', e => mods.tracers = e.target.checked);
  aimbotToggle.addEventListener('change', e => mods.aimbot = e.target.checked);
  fovSlider.addEventListener('input', e => {
    mods.fov = Number(e.target.value);
    camera.fov = mods.fov;
    camera.updateProjectionMatrix();
  });

  // Toggle mod menu with ';'
  document.addEventListener('keydown', e => {
    if (e.key === ';') {
      if (modMenu.style.display === 'none' || modMenu.style.display === '') {
        modMenu.style.display = 'block';
      } else {
        modMenu.style.display = 'none';
      }
    }
  });

  // Other players dummy data for ESP and aimbot demonstration
  // In real game these would be other player objects received from server
  const otherPlayers = [
    {id: 1, position: new THREE.Vector3(3, 1.6, -2)},
    {id: 2, position: new THREE.Vector3(-4, 1.6, 1)},
    {id: 3, position: new THREE.Vector3(1, 1.6, 3)},
  ];

  // Box helper for ESP
  const espBoxes = otherPlayers.map(p => {
    const box = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1)), 0xff0000);
    scene.add(box);
    return box;
  });

  // Tracer lines
  const tracerMaterial = new THREE.LineBasicMaterial({color: 0x00ff00});
  const tracerGeometry = new THREE.BufferGeometry();
  const tracerPositions = new Float32Array(6); // 2 points x 3 coords
  tracerGeometry.setAttribute('position', new THREE.BufferAttribute(tracerPositions, 3));
  const tracers = otherPlayers.map(() => new THREE.Line(tracerGeometry.clone(), tracerMaterial));
  tracers.forEach(line => scene.add(line));

  // Raycaster for aimbot targeting
  const raycaster = new THREE.Raycaster();

  // Main animate loop
  let prevTime = performance.now();
  function animate() {
    if (!controls.isLocked) return;

    const time = performance.now();
    const delta = (time - prevTime) / 1000;

    // Movement direction
    player.direction.set(0, 0, 0);
    if (keys['KeyW']) player.direction.z -= 1;
    if (keys['KeyS']) player.direction.z += 1;
    if (keys['KeyA']) player.direction.x -= 1;
    if (keys['KeyD']) player.direction.x += 1;
    player.direction.normalize();

    // Calculate movement velocity
    let moveX = player.direction.x * player.speed * delta;
    let moveZ = player.direction.z * player.speed * delta;

    // Calculate new position candidate
    const pos = controls.getObject().position.clone();
    const newPos = pos.clone();
    newPos.x += moveX;
    if (!checkCollision(new THREE.Vector3(newPos.x, pos.y, pos.z))) pos.x = newPos.x;
    newPos.z += moveZ;
    if (!checkCollision(new THREE.Vector3(pos.x, pos.y, newPos.z))) pos.z = newPos.z;

    // Gravity & jumping (simple)
    velocityY += gravity * delta;
    let newY = pos.y + velocityY * delta;
    if (newY < player.height) {
      velocityY = 0;
      newY = player.height;
      player.canJump = true;
    }
    pos.y = newY;

    controls.getObject().position.copy(pos);

    // ESP Boxes update
    espBoxes.forEach((boxHelper, i) => {
      if (mods.esp) {
        boxHelper.visible = true;
        const p = otherPlayers[i].position;
        boxHelper.box.setFromCenterAndSize(p, new THREE.Vector3(1, 2, 1));
      } else {
        boxHelper.visible = false;
      }
    });

    // Tracers update
    tracers.forEach((line, i) => {
      if (mods.tracers) {
        line.visible = true;
        const pos = controls.getObject().position;
        const targetPos = otherPlayers[i].position;
        const positions = line.geometry.attributes.position.array;
        positions[0] = pos.x;
        positions[1] = pos.y;
        positions[2] = pos.z;
        positions[3] = targetPos.x;
        positions[4] = targetPos.y;
        positions[5] = targetPos.z;
        line.geometry.attributes.position.needsUpdate = true;
      } else {
        line.visible = false;
      }
    });

    // Aimbot (only when right mouse button is down)
    if (mods.aimbot && aiming) {
      // Find closest player within FOV
      let closestPlayer = null;
      let closestAngle = mods.fov * (Math.PI/180); // convert degrees to radians
      const playerPos = controls.getObject().position;

      otherPlayers.forEach(p => {
        const directionToPlayer = new THREE.Vector3().subVectors(p.position, playerPos).normalize();
        const cameraDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const angle = cameraDir.angleTo(directionToPlayer);
        if (angle < closestAngle) {
          closestAngle = angle;
          closestPlayer = p;
        }
      });

      if (closestPlayer) {
        // Smoothly rotate camera toward closest player
        const targetDir = new THREE.Vector3().subVectors(closestPlayer.position, playerPos).normalize();
        const currentDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

        // Slerp to target direction
        const newDir = currentDir.lerp(targetDir, 0.15).normalize();

        // Compute new camera quaternion from direction
        const up = new THREE.Vector3(0, 1, 0);
        const newQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), newDir);
        camera.quaternion.slerp(newQuat, 0.15);
        controls.getObject().quaternion.copy(camera.quaternion);
      }
    }

    prevTime = time;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // Track right mouse button for aimbot aiming
  let aiming = false;
  document.addEventListener('mousedown', e => {
    if (e.button === 2) aiming = true; // right click pressed
  });
  document.addEventListener('mouseup', e => {
    if (e.button === 2) aiming = false; // right click released
  });

  // Resize handling
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
