<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D FPS Game with Guns, Enemies, and Mods</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%; background: #222;
    font-family: Arial, sans-serif;
    color: white;
  }
  #modMenu {
    position: fixed;
    top: 10px; right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 8px;
    width: 200px;
    font-size: 14px;
  }
  #modMenu label {
    display: block;
    margin: 6px 0;
    cursor: pointer;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #555;
  }
</style>
</head>
<body>

<div id="modMenu">
  <strong>Mods</strong><br/>
  <label><input type="checkbox" id="aimbotToggle" /> Aimbot</label>
  <label><input type="checkbox" id="noclipToggle" /> No Clip</label>
  <label><input type="checkbox" id="espToggle" /> ESP (Outline Enemies)</label>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // Setup basic THREE.js scene, camera, and renderer
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x444444);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 10, 5);
  scene.add(light);

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  // Floor
  const floorGeometry = new THREE.PlaneGeometry(100, 100);
  const floorMaterial = new THREE.MeshStandardMaterial({color: 0x222222});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = - Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Obstacles (boxes)
  const obstacles = [];
  const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
  const boxMaterial = new THREE.MeshStandardMaterial({color: 0x6666ff});
  for(let i = 0; i < 10; i++){
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    box.position.set(
      (Math.random() - 0.5) * 40,
      1,
      (Math.random() - 0.5) * 40
    );
    scene.add(box);
    obstacles.push(box);
  }

  // Player setup
  const player = {
    velocity: new THREE.Vector3(0,0,0),
    direction: new THREE.Vector3(),
    speed: 10,
    canJump: false,
    height: 1.7,
    boundingBox: new THREE.Box3(),
    position: new THREE.Vector3(0, 1.7, 10),
  };

  // Set camera starting position
  camera.position.copy(player.position);

  // Pointer lock controls for FPS look
  const controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener('click', () => {
    controls.lock();
  });

  controls.getObject().position.copy(player.position);

  // Movement state
  const move = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    jump: false,
  };

  // Keyboard input handlers
  document.addEventListener('keydown', e => {
    switch(e.code){
      case 'KeyW': move.forward = true; break;
      case 'KeyS': move.backward = true; break;
      case 'KeyA': move.left = true; break;
      case 'KeyD': move.right = true; break;
      case 'Space': 
        if(player.canJump){
          player.velocity.y = 8;
          player.canJump = false;
        }
        break;
    }
  });

  document.addEventListener('keyup', e => {
    switch(e.code){
      case 'KeyW': move.forward = false; break;
      case 'KeyS': move.backward = false; break;
      case 'KeyA': move.left = false; break;
      case 'KeyD': move.right = false; break;
    }
  });

  // Enemy setup
  const enemyGeometry = new THREE.BoxGeometry(1,2,1);
  const enemyMaterial = new THREE.MeshStandardMaterial({color: 0xff5555});
  const enemies = [];

  for(let i = 0; i < 5; i++){
    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial.clone());
    enemy.position.set(
      (Math.random() - 0.5) * 50,
      1,
      (Math.random() - 0.5) * 50
    );
    enemy.userData = { speed: 2, direction: new THREE.Vector3() };
    scene.add(enemy);
    enemies.push(enemy);
  }

  // Bullet setup
  const bullets = [];
  const bulletSpeed = 40;
  const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
  const bulletMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});

  // Mod toggles
  const mods = {
    aimbot: false,
    noclip: false,
    esp: false,
  };

  document.getElementById('aimbotToggle').addEventListener('change', (e) => {
    mods.aimbot = e.target.checked;
  });
  document.getElementById('noclipToggle').addEventListener('change', (e) => {
    mods.noclip = e.target.checked;
  });
  document.getElementById('espToggle').addEventListener('change', (e) => {
    mods.esp = e.target.checked;
  });

  // Raycaster for shooting and obstacle collisions
  const raycaster = new THREE.Raycaster();

  // Clock for delta time
  const clock = new THREE.Clock();

  // Helper function: Check collision of player with obstacles
  function checkCollision(newPos){
    const playerBox = new THREE.Box3().setFromCenterAndSize(
      newPos.clone().add(new THREE.Vector3(0, player.height/2, 0)),
      new THREE.Vector3(1, player.height, 1)
    );

    for(const obs of obstacles){
      const obsBox = new THREE.Box3().setFromObject(obs);
      if(playerBox.intersectsBox(obsBox)) return true;
    }
    return false;
  }

  // Enemy AI simple move towards player
  function updateEnemies(delta){
    enemies.forEach(enemy => {
      const directionToPlayer = player.position.clone().sub(enemy.position);
      directionToPlayer.y = 0; // keep on ground
      const distance = directionToPlayer.length();
      if(distance > 0.5){
        directionToPlayer.normalize();
        enemy.userData.direction.copy(directionToPlayer);
        enemy.position.add(directionToPlayer.multiplyScalar(enemy.userData.speed * delta));
      }
      // Enemy bounding box collision with obstacles (basic)
      // Could add better collision if needed
    });
  }

  // Shoot function
  function shoot(){
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
    bullet.position.copy(camera.position);
    // Direction from camera
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    bullet.userData = {
      velocity: dir.multiplyScalar(bulletSpeed)
    };
    scene.add(bullet);
    bullets.push(bullet);
  }

  // Auto shoot every 0.5 seconds when aimbot active
  let shootCooldown = 0;

  // Aimbot helper: find closest enemy in view and aim towards it
  function aimbot(delta){
    if(!mods.aimbot) return;

    // Find closest enemy in front of player within FOV ~ 90 degrees
    let closestEnemy = null;
    let closestDist = Infinity;
    const cameraDir = new THREE.Vector3();
    camera.getWorldDirection(cameraDir);

    enemies.forEach(enemy => {
      const toEnemy = enemy.position.clone().sub(camera.position);
      const distance = toEnemy.length();
      toEnemy.normalize();
      const angle = cameraDir.angleTo(toEnemy);

      if(angle < Math.PI / 4 && distance < closestDist){
        closestDist = distance;
        closestEnemy = enemy;
      }
    });

    if(closestEnemy){
      // Smoothly rotate controls toward enemy horizontally
      const enemyPos = closestEnemy.position.clone();
      enemyPos.y = camera.position.y; // keep horizontal
      const playerPos = camera.position.clone();
      playerPos.y = camera.position.y;

      const desiredDir = enemyPos.clone().sub(playerPos).normalize();
      const desiredAngle = Math.atan2(desiredDir.x, desiredDir.z);
      
      // Current rotation (yaw) from controls
      const euler = new THREE.Euler().setFromQuaternion(controls.getObject().quaternion);
      let currentYaw = euler.y;

      // Smooth rotation step
      let angleDiff = desiredAngle - currentYaw;

      // Normalize angleDiff between -PI and PI
      angleDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;

      const maxTurnSpeed = 5 * delta; // radians per second
      angleDiff = THREE.MathUtils.clamp(angleDiff, -maxTurnSpeed, maxTurnSpeed);

      currentYaw += angleDiff;

      // Update controls rotation
      euler.y = currentYaw;
      controls.getObject().quaternion.setFromEuler(euler);

      // Auto shoot when roughly aimed
      if(Math.abs(angleDiff) < 0.1){
        if(shootCooldown <= 0){
          shoot();
          shootCooldown = 0.5;
        }
      }
    }
  }

  // Update bullets
  function updateBullets(delta){
    for(let i = bullets.length - 1; i >= 0; i--){
      const b = bullets[i];
      b.position.addScaledVector(b.userData.velocity, delta);

      // Remove bullet if too far
      if(b.position.distanceTo(camera.position) > 100){
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }

      // Check collision with enemies
      for(let j = enemies.length -1; j >=0; j--){
        const enemy = enemies[j];
        const enemyBox = new THREE.Box3().setFromObject(enemy);
        if(enemyBox.containsPoint(b.position)){
          // Hit enemy
          scene.remove(enemy);
          enemies.splice(j, 1);

          // Remove bullet
          scene.remove(b);
          bullets.splice(i,1);
          break;
        }
      }
    }
  }

  // Basic player collision and movement
  function playerMovement(delta){
    player.velocity.x -= player.velocity.x * 10.0 * delta;
    player.velocity.z -= player.velocity.z * 10.0 * delta;
    player.velocity.y -= 9.8 * 5 * delta; // gravity

    player.direction.z = Number(move.forward) - Number(move.backward);
    player.direction.x = Number(move.right) - Number(move.left);
    player.direction.normalize();

    if(move.forward || move.backward) player.velocity.z -= player.direction.z * player.speed * delta;
    if(move.left || move.right) player.velocity.x -= player.direction.x * player.speed * delta;

    // Calculate new position based on velocity and controls rotation
    const controlObject = controls.getObject();

    // Convert velocity from local space to world space
    const velocity = new THREE.Vector3(player.velocity.x, player.velocity.y, player.velocity.z);
    const euler = new THREE.Euler(0, controlObject.rotation.y, 0, 'YXZ');
    velocity.applyEuler(euler);

    const newPos = controlObject.position.clone().add(velocity.clone().multiplyScalar(delta));

    // Ground check and collision
    if(!mods.noclip){
      if(newPos.y < player.height){
        player.velocity.y = 0;
        newPos.y = player.height;
        player.canJump = true;
      }

      // Check collisions with obstacles only if not noclip
      if(!checkCollision(newPos)){
        controlObject.position.copy(newPos);
      }
    } else {
      // noclip mode just moves freely
      controlObject.position.copy(newPos);
      if(newPos.y < 0) controlObject.position.y = 0;
      player.canJump = true;
    }

    camera.position.copy(controlObject.position);
  }

  // ESP (outline enemies)
  function updateESP(){
    enemies.forEach(enemy => {
      if(mods.esp){
        enemy.material.emissive = new THREE.Color(0x00ff00);
        enemy.material.emissiveIntensity = 0.5;
      } else {
        enemy.material.emissiveIntensity = 0;
      }
    });
  }

  // Animate loop
  function animate(){
    const delta = clock.getDelta();
    shootCooldown -= delta;

    if(controls.isLocked === true){
      playerMovement(delta);
      updateEnemies(delta);
      aimbot(delta);
      updateBullets(delta);
      updateESP();
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  animate();

  // Window resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>
</body>
</html>
